{ config, lib }:

with lib;
let
  # Despite the name, Apple doesn't actually care about UUID format compliance
  # as long as the value is unique.
  makeUUID = value: builtins.hashString "sha256" (builtins.toJSON value);

  plistDataPrefix = "__PLIST_DATA_START__";
  plistDataSuffix = "__PLIST_DATA_END__";
in
{
  mkPayloadOptions =
    {
      type,
      defaultIdentifier,
      defaultDisplayName ? null,
      contentType ? mkOption {
        type = types.any;
        description = "The actual content for this payload";
      },
    }:
    # All the keys in this attrset directly map to a corresponding `Payload*`
    # key in the plist generated by payload2Plist.
    {
      type = mkOption {
        type = types.singleLineStr;
        default = type;
        readOnly = true;
      };

      version = mkOption {
        type = types.int;
        default = 1;
        readOnly = true;
      };

      identifier = mkOption {
        type = types.singleLineStr;
        description = ''
          A reverse-DNS style identifier for this payload.
          Must be unique within the profile.
        '';
        default = defaultIdentifier;
        example = "com.example.nix-managed";
      };

      UUID = mkOption {
        type = types.singleLineStr;
        readOnly = true;
        description = "Auto-generated UUID for this payload. Do not set manually";
      };

      displayName = mkOption {
        type = types.nullOr types.str;
        default = defaultDisplayName;
        description = "Human-readable name shown in System Settings > Profiles";
        example = "Nix Managed Profile";
      };

      description = mkOption {
        type = types.nullOr types.str;
        description = "Optional longer description of the payload's purpose";
        default = null;
      };

      organization = mkOption {
        type = types.nullOr types.singleLineStr;
        description = "Organization name to display in System Settings";
        default = null;
      };

      content = contentType;
    };

  # A thin wrapper around lib.generators.toPlist that recognizes the values
  # created with `mkPlistData` and wraps them in `<data/>` tags.
  mkPlist =
    value:
    let
      xml = lib.generators.toPlist { escape = true; } value;
    in
    lib.replaceStrings
      [ "<string>${plistDataPrefix}" "${plistDataSuffix}</string>" ]
      [ "<data>" "</data>" ]
      xml;

  # Base64-encodes a string and wraps it in sentinel markers so mkPlist can emit
  # it as a <data> element instead of a <string>.
  mkPlistData =
    string:
    "${plistDataPrefix}${config.lib.mine.base64Encode string}${plistDataSuffix}";

  # Converts the given payload config generated by `mkPayloadOptions` into
  # the corresponding plist attrset.
  payload2Plist = payloadCfg: {
    PayloadType = payloadCfg.type;
    PayloadVersion = payloadCfg.version;
    PayloadIdentifier = payloadCfg.identifier;
    PayloadUUID = makeUUID {
      identifier = payloadCfg.identifier;
      type = payloadCfg.type;
    };
    PayloadDisplayName = payloadCfg.displayName;
    PayloadDescription = payloadCfg.description;
    PayloadOrganization = payloadCfg.organization;
    PayloadContent = payloadCfg.content;
  };

  # The type of a Plist-compatible value.
  plistType = types.nullOr (
    types.oneOf [
      types.bool
      types.int
      types.float
      types.str
      (types.listOf valueType)
      (types.attrsOf valueType)
    ]
  );
}
